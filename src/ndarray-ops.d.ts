import ndarray from 'ndarray';

declare const ops: {
  add(dest: ndarray, arg1: ndarray, arg2: ndarray): void;
  addeq(dest: ndarray, arg1: ndarray): void;
  adds(dest: ndarray, arg1: ndarray, num: number): void;
  addseq(dest: ndarray, num: number): void;
  sub(dest: ndarray, arg1: ndarray, arg2: ndarray): void;
  subeq(dest: ndarray, arg1: ndarray): void;
  subs(dest: ndarray, arg1: ndarray, num: number): void;
  subseq(dest: ndarray, num: number): void;
  mul(dest: ndarray, arg1: ndarray, arg2: ndarray): void;
  muleq(dest: ndarray, arg1: ndarray): void;
  muls(dest: ndarray, arg1: ndarray, num: number): void;
  mulseq(dest: ndarray, num: number): void;
  div(dest: ndarray, arg1: ndarray, arg2: ndarray): void;
  diveq(dest: ndarray, arg1: ndarray): void;
  divs(dest: ndarray, arg1: ndarray, num: number): void;
  divseq(dest: ndarray, num: number): void;
  mod(dest: ndarray, arg1: ndarray, arg2: ndarray): void;
  modeq(dest: ndarray, arg1: ndarray): void;
  mods(dest: ndarray, arg1: ndarray, num: number): void;
  modseq(dest: ndarray, num: number): void;
  band(dest: ndarray, arg1: ndarray, arg2: ndarray): void;
  bandeq(dest: ndarray, arg1: ndarray): void;
  bands(dest: ndarray, arg1: ndarray, num: number): void;
  bandseq(dest: ndarray, num: number): void;
  bor(dest: ndarray, arg1: ndarray, arg2: ndarray): void;
  boreq(dest: ndarray, arg1: ndarray): void;
  bors(dest: ndarray, arg1: ndarray, num: number): void;
  borseq(dest: ndarray, num: number): void;
  bxor(dest: ndarray, arg1: ndarray, arg2: ndarray): void;
  bxoreq(dest: ndarray, arg1: ndarray): void;
  bxors(dest: ndarray, arg1: ndarray, num: number): void;
  bxorseq(dest: ndarray, num: number): void;
  lshift(dest: ndarray, arg1: ndarray, arg2: ndarray): void;
  lshifteq(dest: ndarray, arg1: ndarray): void;
  lshifts(dest: ndarray, arg1: ndarray, num: number): void;
  lshiftseq(dest: ndarray, num: number): void;
  rshift(dest: ndarray, arg1: ndarray, arg2: ndarray): void;
  rshifteq(dest: ndarray, arg1: ndarray): void;
  rshifts(dest: ndarray, arg1: ndarray, num: number): void;
  rshiftseq(dest: ndarray, num: number): void;
  rrshift(dest: ndarray, arg1: ndarray, arg2: ndarray): void;
  rrshifteq(dest: ndarray, arg1: ndarray): void;
  rrshifts(dest: ndarray, arg1: ndarray, num: number): void;
  rrshiftseq(dest: ndarray, num: number): void;
  lt(dest: ndarray, arg1: ndarray, arg2: ndarray): void;
  lteq(dest: ndarray, arg1: ndarray): void;
  lts(dest: ndarray, arg1: ndarray, num: number): void;
  ltseq(dest: ndarray, num: number): void;
  gt(dest: ndarray, arg1: ndarray, arg2: ndarray): void;
  gteq(dest: ndarray, arg1: ndarray): void;
  gts(dest: ndarray, arg1: ndarray, num: number): void;
  gtseq(dest: ndarray, num: number): void;
  leq(dest: ndarray, arg1: ndarray, arg2: ndarray): void;
  leqeq(dest: ndarray, arg1: ndarray): void;
  leqs(dest: ndarray, arg1: ndarray, num: number): void;
  leqseq(dest: ndarray, num: number): void;
  geq(dest: ndarray, arg1: ndarray, arg2: ndarray): void;
  geqeq(dest: ndarray, arg1: ndarray): void;
  geqs(dest: ndarray, arg1: ndarray, num: number): void;
  geqseq(dest: ndarray, num: number): void;
  eq(dest: ndarray, arg1: ndarray, arg2: ndarray): void;
  eqeq(dest: ndarray, arg1: ndarray): void;
  eqs(dest: ndarray, arg1: ndarray, num: number): void;
  eqseq(dest: ndarray, num: number): void;
  neq(dest: ndarray, arg1: ndarray, arg2: ndarray): void;
  neqeq(dest: ndarray, arg1: ndarray): void;
  neqs(dest: ndarray, arg1: ndarray, num: number): void;
  neqseq(dest: ndarray, num: number): void;
  and(dest: ndarray, arg1: ndarray, arg2: ndarray): void;
  andeq(dest: ndarray, arg1: ndarray): void;
  ands(dest: ndarray, arg1: ndarray, num: number): void;
  andseq(dest: ndarray, num: number): void;
  or(dest: ndarray, arg1: ndarray, arg2: ndarray): void;
  oreq(dest: ndarray, arg1: ndarray): void;
  ors(dest: ndarray, arg1: ndarray, num: number): void;
  orseq(dest: ndarray, num: number): void;
  max(dest: ndarray, arg1: ndarray, arg2: ndarray): void;
  maxeq(dest: ndarray, arg1: ndarray): void;
  maxs(dest: ndarray, arg1: ndarray, num: number): void;
  maxseq(dest: ndarray, num: number): void;
  min(dest: ndarray, arg1: ndarray, arg2: ndarray): void;
  mineq(dest: ndarray, arg1: ndarray): void;
  mins(dest: ndarray, arg1: ndarray, num: number): void;
  minseq(dest: ndarray, num: number): void;
  assign(arg1: ndarray, arg2: ndarray): void;
  assigns(arg1: ndarray, num: number): void;
  random(arg: ndarray): void;
  not(dest: ndarray, arg: ndarray): void;
  noteq(dest: ndarray): void;
  bnot(dest: ndarray, arg: ndarray): void;
  bnoteq(dest: ndarray): void;
  neg(dest: ndarray, arg: ndarray): void;
  negeq(dest: ndarray): void;
  recip(dest: ndarray, arg: ndarray): void;
  recipeq(dest: ndarray): void;
  abs(dest: ndarray, arg: ndarray): void;
  abseq(dest: ndarray): void;
  acos(dest: ndarray, arg: ndarray): void;
  acoseq(dest: ndarray): void;
  asin(dest: ndarray, arg: ndarray): void;
  asineq(dest: ndarray): void;
  atan(dest: ndarray, arg: ndarray): void;
  ataneq(dest: ndarray): void;
  ceil(dest: ndarray, arg: ndarray): void;
  ceileq(dest: ndarray): void;
  cos(dest: ndarray, arg: ndarray): void;
  coseq(dest: ndarray): void;
  exp(dest: ndarray, arg: ndarray): void;
  expeq(dest: ndarray): void;
  floor(dest: ndarray, arg: ndarray): void;
  flooreq(dest: ndarray): void;
  log(dest: ndarray, arg: ndarray): void;
  logeq(dest: ndarray): void;
  round(dest: ndarray, arg: ndarray): void;
  roundeq(dest: ndarray): void;
  sin(dest: ndarray, arg: ndarray): void;
  sineq(dest: ndarray): void;
  sqrt(dest: ndarray, arg: ndarray): void;
  sqrteq(dest: ndarray): void;
  tan(dest: ndarray, arg: ndarray): void;
  taneq(dest: ndarray): void;
  atan(dest: ndarray, arg1: ndarray, arg2: ndarray): void;
  ataneq(dest: ndarray, arg1: ndarray): void;
  atans(dest: ndarray, arg1: ndarray, num: number): void;
  atanseq(dest: ndarray, num: number): void;
  atanop(dest: ndarray, arg1: ndarray, arg2: ndarray): void;
  atanopeq(dest: ndarray, arg1: ndarray): void;
  atansop(dest: ndarray, arg1: ndarray, num: number): void;
  atansopeq(dest: ndarray, num: number): void;
  pow(dest: ndarray, arg1: ndarray, arg2: ndarray): void;
  poweq(dest: ndarray, arg1: ndarray): void;
  pows(dest: ndarray, arg1: ndarray, num: number): void;
  powseq(dest: ndarray, num: number): void;
  powop(dest: ndarray, arg1: ndarray, arg2: ndarray): void;
  powopeq(dest: ndarray, arg1: ndarray): void;
  powsop(dest: ndarray, arg1: ndarray, num: number): void;
  powsopeq(dest: ndarray, num: number): void;
  equals(arg1: ndarray, arg2: ndarray): boolean;
  any(arg: ndarray): boolean;
  all(arg: ndarray): boolean;
  sum(arg: ndarray): number;
  prod(arg: ndarray): number;
  norm2squared(arg: ndarray): number;
  norm2(arg: ndarray): number;
  norminf(arg: ndarray): number;
  norm1(arg: ndarray): number;
  sup(arg: ndarray): number;
  inf(arg: ndarray): number;
  argmin(arg: ndarray): number[];
  argmax(arg: ndarray): number[];
};

declare module 'ndarray-ops' {
  export = ops;
}